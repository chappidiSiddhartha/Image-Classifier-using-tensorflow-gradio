# -*- coding: utf-8 -*-
"""main

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WfnNHnQ6XSDgx1J4zEV8Wz_nXvn3whJQ
"""

!pip install gradio

import tensorflow as tf
device_name = tf.test.gpu_device_name()
print(device_name)
print('Found GPU at: {}'.format(device_name))

import gradio as gr
import numpy as np
import tensorflow as tf
import cv2

# Load MNIST dataset
mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0  # Normalize data

# Build a model with more layers
model = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)),
    tf.keras.layers.Dense(512, activation='relu'),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(256, activation='relu'),  # Added layer
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(128, activation='relu'),  # Added layer
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10)
])


model.compile(optimizer='adam',
              loss=tf.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=8)

def classify_digit(img):
    # Extract pixel values from the 'background' array
    img_values = np.array(img['background'])

    # Convert the pixel values to grayscale
    img_values = np.mean(img_values, axis=-1)

    # Resize the image to 28x28
    img_values_resized = cv2.resize(img_values, (28, 28), interpolation=cv2.INTER_AREA)

    # Reshape the resized image
    img_values_reshaped = img_values_resized.reshape(1, 28, 28)

    # Normalize the image
    img_values_normalized = img_values_reshaped / 255.0

    # Make a prediction
    prediction = model.predict(img_values_normalized).tolist()[0]

    # Return the predictions as a dictionary
    return {str(i): prediction[i] for i in range(10)}


# Gradio UI
interface = gr.Interface(fn=classify_digit,
                         inputs="sketchpad",
                         outputs="label")
interface.launch(debug=True)



